import { swap } from "./visualize.js";

// Сортировка пузырьком.
export const bubbleSort = async (length, array) => {
	/*
		Последовательно проходим по массиву.
		Сравниваем соседние элементы между собой.
		Вычитаем из диапазона те элементы, которые уже на своем месте в 
		конце массива.
		*/
	for (let i = 0; i < length - 1; i += 1) {
		for (let j = 0; j < length - i - 1; j += 1) {
			// Если элемент больше следующего - обмениваем их местами.
			if (array[j] > array[j + 1]) {
				await swap(j, j + 1, length, array);
			}
		}
	}
};

// Сортировка выбором.
export const selectionSort = async (length, array) => {
	// Берем текущий элемент массива.
	for (let i = 0; i < length - 1; i += 1) {
		// Принимаем его за минимальный.
		let min = i;
		/*
			Последовательно сравниваем значение минимального с элементами после текущего.
			Если элемент меньше минимального - записываем его минимальным.
			*/
		for (let j = i + 1; j < length; j += 1) {
			if (array[j] < array[min]) {
				min = j;
			}
		}
		// Меняем местами текущий и минимальный элементы.
		if (min != i) {
			await swap(i, min, length, array);
		}
	}
};

// Сортировка вставками.
export const insertionSort = async (length, array) => {
	// Начинаем со второго элемента массива.
	for (let i = 1; i < length; i += 1) {
		let cur = array[i];

		// Двигаем элемент влево, пока он меньше предыдущего и его индекс больше ноля.
		let j = i - 1;
		while (j >= 0 && array[j] > cur) {
			// Отрисовываем сдвиг влево.
			await swap(j, j + 1, length, array);
			j -= 1;
		}
		array[j + 1] = cur;
	}
};

// Разбиение и сортировка массива на две части для быстрой сортировки.
const partition = async (min, max, length, array) => {
	// Принимаем за опорный последний элемент переданного массива.
	const pivot = array[max];
	// Создаем левый указатель.
	let i = min - 1;
	/*
		Создаем правый указатель.
		Последовательно сравниваем элементы, на которых стоит правый указатель с 
		опорным. Если элемент правого указателя меньше опорного, то меняем его
		местами с элементом, на который указывает левый указатель.
		*/
	for (let j = min; j < max; j += 1) {
		if (array[j] <= pivot) {
			// Перемещаем левый указатель.
			i += 1;
			// Исключаем запуск свапа при указателях на одном элементе.
			if (i != j) await swap(i, j, length, array);
		}
	}
	/*
		Помещаем опорный элемент на место первого элемента в массиве из элементов
		больше опорного.

		Таким образом мы получам два массива: до опорного и от опорного. При этом 
		любой элемент первого массива меньше любого элемента второго массива.
		*/
	await swap(i + 1, max, length, array);
	// 	Возвращаем новый индекс опорного элемента.
	return i + 1;
};

// Быстрая сортировка.
export const quickSort = async (min, max, length, array) => {
	if (min < max) {
		// Разбиваем массив на две части.
		let pi = await partition(min, max, length, array);
		// Рекурсивно сортируем полученные массивы.
		await quickSort(min, pi - 1, length, array);
		await quickSort(pi + 1, max, length, array);
	}
};

// Функция для создания узла кучи.
// i - первый элемент переданного массива.
// size - размер массива.
const heapify = async (i, size, length, array) => {
	// Записываем элемент с индексом 0 как корень.
	let largest = i;
	// Индекс первого дочернего элемента (левая ветвь).
	let left = 2 * i + 1;
	// Индекс второго дочернего элемента (правая ветвь).
	let right = 2 * i + 2;

	// Если дочерний элемент больше наибольшего - записываем его в наибольший.
	if (left < size && array[left] > array[largest]) {
		largest = left;
	}
	if (right < size && array[right] > array[largest]) {
		largest = right;
	}

	/*
		Если наибольший элемент не является корнем подмассива, то меняем их местами.
		Получаем отсортированный "узел" двоичного дерева.
		*/
	if (largest != i) {
		await swap(i, largest, length, array);
		/*
			Значение по индексу largest изменилось. Рекурсивно проходим по его 
			дочерним элементам.
			*/
		await heapify(largest, size, length, array);
	}
};

// Сортировка кучей (пирамидальная сортировка).
export const heapSort = async (length, array) => {
	/*	
		Перемещаем в начало корень (наибольший элемент) двоичного дерева.
		Формируется "возрастающая куча" - двоичное дерево, где каждый родитель
		больше, чем любой из его потомков.
		*/
	for (let i = Math.floor(length / 2) - 1; i >= 0; i -= 1) {
		await heapify(i, length, length, array);
	}
	/*
		Обмениваем корень кучи (наибольший элемент) с последним элементом 
		неотсортированной части массива.
		Теперь неотсортированная часть меньше на единицу.
		Проходим неотсортированной части, снова получая кучу.
		*/
	for (let i = length - 1; i > 0; i -= 1) {
		await swap(0, i, length, array);
		await heapify(0, i, length, array);
	}
};
